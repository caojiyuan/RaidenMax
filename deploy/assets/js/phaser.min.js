/**
 * 简化版Phaser库 - 只包含基本功能
 */

// 创建Phaser命名空间
window.Phaser = {
    // 渲染器类型
    AUTO: 0,
    CANVAS: 1,
    WEBGL: 2,
    
    // 数学工具
    Math: {
        Between: function(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min; // 生成指定范围内的随机整数
        },
        FloatBetween: function(min, max) {
            return Math.random() * (max - min) + min; // 生成指定范围内的随机浮点数
        }
    },
    
    // 输入键盘代码
    Input: {
        Keyboard: {
            KeyCodes: {
                SPACE: 32, // 空格键
                LEFT: 37,  // 左方向键
                UP: 38,    // 上方向键
                RIGHT: 39, // 右方向键
                DOWN: 40   // 下方向键
            }
        }
    }
};

// 图形类
Phaser.Graphics = class {
    constructor(scene, options) {
        this.scene = scene; // 场景
        this.commands = []; // 绘图命令
    }
    
    // 设置填充样式
    fillStyle(color, alpha) {
        this.commands.push({ type: 'fillStyle', color, alpha }); // 添加命令
        return this; // 返回自身
    }
    
    // 填充矩形
    fillRect(x, y, width, height) {
        this.commands.push({ type: 'fillRect', x, y, width, height }); // 添加命令
        return this; // 返回自身
    }
    
    // 填充圆形
    fillCircle(x, y, radius) {
        this.commands.push({ type: 'fillCircle', x, y, radius }); // 添加命令
        return this; // 返回自身
    }
    
    // 填充三角形
    fillTriangle(x1, y1, x2, y2, x3, y3) {
        this.commands.push({ type: 'fillTriangle', x1, y1, x2, y2, x3, y3 }); // 添加命令
        return this; // 返回自身
    }
    
    // 生成纹理
    generateTexture(key, width, height) {
        // 创建离屏画布
        const canvas = document.createElement('canvas'); // 创建画布
        canvas.width = width; // 设置宽度
        canvas.height = height; // 设置高度
        const context = canvas.getContext('2d'); // 获取上下文
        
        // 执行绘图命令
        for (const cmd of this.commands) {
            switch (cmd.type) {
                case 'fillStyle':
                    context.fillStyle = typeof cmd.color === 'number' 
                        ? `#${cmd.color.toString(16).padStart(6, '0')}` // 十六进制颜色
                        : cmd.color; // 颜色字符串
                    context.globalAlpha = cmd.alpha || 1; // 透明度
                    break;
                case 'fillRect':
                    context.fillRect(cmd.x, cmd.y, cmd.width, cmd.height); // 填充矩形
                    break;
                case 'fillCircle':
                    context.beginPath(); // 开始路径
                    context.arc(cmd.x, cmd.y, cmd.radius, 0, Math.PI * 2); // 绘制圆
                    context.fill(); // 填充
                    break;
                case 'fillTriangle':
                    context.beginPath(); // 开始路径
                    context.moveTo(cmd.x1, cmd.y1); // 移动到第一个点
                    context.lineTo(cmd.x2, cmd.y2); // 连接到第二个点
                    context.lineTo(cmd.x3, cmd.y3); // 连接到第三个点
                    context.closePath(); // 闭合路径
                    context.fill(); // 填充
                    break;
            }
        }
        
        // 创建图像并保存到纹理
        const image = new Image(); // 创建图像
        image.src = canvas.toDataURL(); // 设置源
        this.scene.textures[key] = image; // 保存纹理
        
        return key; // 返回纹理键
    }
};

// 图像类
Phaser.Image = class {
    constructor(scene, x, y, key) {
        this.scene = scene; // 场景
        this.x = x; // X坐标
        this.y = y; // Y坐标
        this.key = key; // 纹理键
        this.alpha = 1; // 透明度
        this.visible = true; // 可见性
        this.scale = { x: 1, y: 1 }; // 缩放
        this.scrollFactor = { x: 1, y: 1 }; // 滚动因子
    }
    
    // 设置滚动因子
    setScrollFactor(factor) {
        this.scrollFactor.x = factor; // 设置X滚动因子
        this.scrollFactor.y = factor; // 设置Y滚动因子
        return this; // 返回自身
    }
    
    // 设置缩放
    setScale(scale) {
        this.scale.x = scale; // 设置X缩放
        this.scale.y = scale; // 设置Y缩放
        return this; // 返回自身
    }
    
    // 设置原点
    setOrigin(x, y) {
        this.originX = x; // 设置X原点
        this.originY = y; // 设置Y原点
        return this; // 返回自身
    }
    
    // 渲染
    render(context) {
        if (!this.visible) return; // 如果不可见，不渲染
        
        const texture = this.scene.textures[this.key]; // 获取纹理
        if (!texture) return; // 如果没有纹理，不渲染
        
        context.globalAlpha = this.alpha; // 设置透明度
        context.drawImage(
            texture, // 纹理
            this.x - (this.originX || 0) * texture.width * this.scale.x, // X位置
            this.y - (this.originY || 0) * texture.height * this.scale.y, // Y位置
            texture.width * this.scale.x, // 宽度
            texture.height * this.scale.y // 高度
        );
        context.globalAlpha = 1; // 重置透明度
    }
};

// 精灵类
Phaser.Sprite = class {
    constructor(scene, x, y, key) {
        this.scene = scene; // 场景
        this.x = x; // X坐标
        this.y = y; // Y坐标
        this.key = key; // 纹理键
        this.alpha = 1; // 透明度
        this.visible = true; // 可见性
        this.scale = { x: 1, y: 1 }; // 缩放
        this.scrollFactor = { x: 1, y: 1 }; // 滚动因子
        this.originX = 0; // X原点
        this.originY = 0; // Y原点
    }
    
    // 设置滚动因子
    setScrollFactor(factor) {
        this.scrollFactor.x = factor; // 设置X滚动因子
        this.scrollFactor.y = factor; // 设置Y滚动因子
        return this; // 返回自身
    }
    
    // 设置缩放
    setScale(scale) {
        this.scale.x = scale; // 设置X缩放
        this.scale.y = scale; // 设置Y缩放
        return this; // 返回自身
    }
    
    // 设置原点
    setOrigin(x, y) {
        this.originX = x; // 设置X原点
        this.originY = y; // 设置Y原点
        return this; // 返回自身
    }
    
    // 更新
    update() {
        // 更新精灵
    }
    
    // 销毁
    destroy() {
        const index = this.scene.children.indexOf(this); // 获取索引
        if (index !== -1) {
            this.scene.children.splice(index, 1); // 从子对象中移除
        }
    }
    
    // 渲染
    render(context) {
        if (!this.visible) return; // 如果不可见，不渲染
        
        const texture = this.scene.textures[this.key]; // 获取纹理
        if (!texture) return; // 如果没有纹理，不渲染
        
        context.globalAlpha = this.alpha; // 设置透明度
        context.drawImage(
            texture, // 纹理
            this.x - (this.originX || 0) * texture.width * this.scale.x, // X位置
            this.y - (this.originY || 0) * texture.height * this.scale.y, // Y位置
            texture.width * this.scale.x, // 宽度
            texture.height * this.scale.y // 高度
        );
        context.globalAlpha = 1; // 重置透明度
    }
};

// 文本类
Phaser.Text = class {
    constructor(scene, x, y, text, style) {
        this.scene = scene; // 场景
        this.x = x; // X坐标
        this.y = y; // Y坐标
        this.text = text; // 文本
        this.style = style || {}; // 样式
        this.alpha = 1; // 透明度
        this.visible = true; // 可见性
        this.originX = 0; // X原点
        this.originY = 0; // Y原点
    }
    
    // 设置文本
    setText(text) {
        this.text = text; // 设置文本
        return this; // 返回自身
    }
    
    // 设置原点
    setOrigin(x, y) {
        this.originX = x; // 设置X原点
        this.originY = y || x; // 设置Y原点
        return this; // 返回自身
    }
    
    // 渲染
    render(context) {
        if (!this.visible) return; // 如果不可见，不渲染
        
        context.globalAlpha = this.alpha; // 设置透明度
        
        // 设置字体
        const fontSize = this.style.fontSize || '16px'; // 字体大小
        const fontFamily = this.style.fontFamily || 'Arial'; // 字体
        context.font = `${fontSize} ${fontFamily}`; // 设置字体
        
        // 设置颜色
        context.fillStyle = this.style.fill || '#fff'; // 填充颜色
        
        // 计算文本宽度
        const textWidth = context.measureText(this.text).width; // 文本宽度
        
        // 计算位置
        const x = this.x - this.originX * textWidth; // X位置
        const y = this.y + (parseInt(fontSize) / 2); // Y位置
        
        // 绘制文本
        context.fillText(this.text, x, y); // 绘制文本
        
        context.globalAlpha = 1; // 重置透明度
    }
};

// 组类
Phaser.Group = class {
    constructor(scene) {
        this.scene = scene; // 场景
        this.children = []; // 子对象
    }
    
    // 添加
    add(child) {
        this.children.push(child); // 添加子对象
        return child; // 返回子对象
    }
    
    // 渲染
    render(context) {
        for (const child of this.children) {
            if (child.render) {
                child.render(context); // 渲染子对象
            }
        }
    }
    
    // 绘制
    draw(context) {
        this.render(context); // 渲染
    }
};

// 物理精灵
Phaser.Physics = {};

Phaser.Physics.Sprite = class {
    constructor(scene, x, y, key) {
        this.scene = scene; // 场景
        this.x = x; // X坐标
        this.y = y; // Y坐标
        this.key = key; // 纹理键
        this.alpha = 1; // 透明度
        this.visible = true; // 可见性
        this.scale = { x: 1, y: 1 }; // 缩放
        this.scrollFactor = { x: 1, y: 1 }; // 滚动因子
        this.originX = 0; // X原点
        this.originY = 0; // Y原点
        this.body = {
            velocity: { x: 0, y: 0 } // 速度
        };
        this.collideWorldBounds = false; // 是否碰撞世界边界
        this.tint = 0xffffff; // 着色
    }
    
    // 设置X速度
    setVelocityX(vx) {
        this.body.velocity.x = vx; // 设置X速度
        return this; // 返回自身
    }
    
    // 设置Y速度
    setVelocityY(vy) {
        this.body.velocity.y = vy; // 设置Y速度
        return this; // 返回自身
    }
    
    // 设置碰撞边界
    setCollideWorldBounds(collide) {
        this.collideWorldBounds = collide; // 设置碰撞边界
        return this; // 返回自身
    }
    
    // 着色
    setTint(color) {
        this.tint = color; // 设置着色
        return this; // 返回自身
    }
    
    // 更新
    update() {
        // 更新位置
        this.x += this.body.velocity.x / 60; // 更新X位置
        this.y += this.body.velocity.y / 60; // 更新Y位置
        
        // 碰撞边界检测
        if (this.collideWorldBounds) {
            if (this.x < 0) this.x = 0; // 左边界
            if (this.y < 0) this.y = 0; // 上边界
            if (this.x > this.scene.game.width) this.x = this.scene.game.width; // 右边界
            if (this.y > this.scene.game.height) this.y = this.scene.game.height; // 下边界
        }
    }
    
    // 销毁
    destroy() {
        const index = this.scene.children.indexOf(this); // 获取索引
        if (index !== -1) {
            this.scene.children.splice(index, 1); // 从子对象中移除
        }
    }
    
    // 渲染
    render(context) {
        if (!this.visible) return; // 如果不可见，不渲染
        
        const texture = this.scene.textures[this.key]; // 获取纹理
        if (!texture) return; // 如果没有纹理，不渲染
        
        context.globalAlpha = this.alpha; // 设置透明度
        context.drawImage(
            texture, // 纹理
            this.x - (this.originX || 0) * texture.width * this.scale.x, // X位置
            this.y - (this.originY || 0) * texture.height * this.scale.y, // Y位置
            texture.width * this.scale.x, // 宽度
            texture.height * this.scale.y // 高度
        );
        context.globalAlpha = 1; // 重置透明度
    }
};

// 物理组
Phaser.Physics.Group = class {
    constructor(scene) {
        this.scene = scene; // 场景
        this.children = []; // 子对象
    }
    
    // 添加
    add(child) {
        this.children.push(child); // 添加子对象
        return child; // 返回子对象
    }
    
    // 创建
    create(x, y, key) {
        const sprite = new Phaser.Physics.Sprite(this.scene, x, y, key); // 创建物理精灵
        this.add(sprite); // 添加到组
        return sprite; // 返回精灵
    }
    
    // 渲染
    render(context) {
        for (const child of this.children) {
            if (child.render) {
                child.render(context); // 渲染子对象
            }
        }
    }
    
    // 绘制
    draw(context) {
        this.render(context); // 渲染
    }
};

// 物理系统
Phaser.Physics.Arcade = class {
    constructor(config) {
        this.config = config; // 配置
    }
};

// 游戏类
Phaser.Game = class {
    constructor(config) {
        this.config = config; // 保存配置
        this.width = config.width || 800; // 游戏宽度
        this.height = config.height || 600; // 游戏高度
        
        // 创建画布
        this.canvas = document.createElement('canvas'); // 创建画布元素
        this.canvas.width = this.width; // 设置宽度
        this.canvas.height = this.height; // 设置高度
        this.context = this.canvas.getContext('2d'); // 获取2D上下文
        
        // 将画布添加到容器
        const container = document.getElementById(config.parent); // 获取父容器
        if (container) {
            container.appendChild(this.canvas); // 添加画布到容器
        } else {
            document.body.appendChild(this.canvas); // 添加到body
        }
        
        // 创建场景
        this.scene = new Phaser.Scene(this); // 创建场景
        
        // 初始化输入系统
        this.input = new Phaser.Input(this); // 创建输入系统
        
        // 初始化物理系统
        this.physics = new Phaser.Physics(this); // 创建物理系统
        
        // 场景函数
        if (config.scene) {
            if (config.scene.preload) {
                config.scene.preload.call(this.scene); // 调用预加载函数
            }
            if (config.scene.create) {
                config.scene.create.call(this.scene); // 调用创建函数
            }
            
            // 更新循环
            const update = config.scene.update; // 获取更新函数
            if (update) {
                this.lastTime = 0; // 上次更新时间
                const gameLoop = (time) => {
                    update.call(this.scene, time); // 调用更新函数
                    this.render(); // 渲染
                    requestAnimationFrame(gameLoop); // 继续循环
                };
                requestAnimationFrame(gameLoop); // 开始游戏循环
            }
        }
    }
    
    // 渲染函数
    render() {
        this.context.fillStyle = '#000'; // 背景色
        this.context.fillRect(0, 0, this.width, this.height); // 清空画布
        
        // 渲染所有游戏对象
        this.scene.renderObjects(); // 渲染场景对象
    }
};

// 场景类
Phaser.Scene = class {
    constructor(game) {
        this.game = game; // 游戏实例
        this.children = []; // 子对象
        this.textures = {}; // 纹理
        this.groups = []; // 组
        
        // 添加方法
        this.add = {
            // 添加图像
            image: (x, y, key) => {
                const image = new Phaser.Image(this, x, y, key); // 创建图像
                this.children.push(image); // 添加到子对象
                return image; // 返回图像
            },
            
            // 添加精灵
            sprite: (x, y, key) => {
                const sprite = new Phaser.Sprite(this, x, y, key); // 创建精灵
                this.children.push(sprite); // 添加到子对象
                return sprite; // 返回精灵
            },
            
            // 添加文本
            text: (x, y, text, style) => {
                const textObj = new Phaser.Text(this, x, y, text, style); // 创建文本
                this.children.push(textObj); // 添加到子对象
                return textObj; // 返回文本
            },
            
            // 添加组
            group: () => {
                const group = new Phaser.Group(this); // 创建组
                this.groups.push(group); // 添加到组列表
                return group; // 返回组
            },
            
            // 创建图形
            graphics: (options) => {
                const graphics = new Phaser.Graphics(this, options); // 创建图形
                if (options && options.add !== false) {
                    this.children.push(graphics); // 添加到子对象
                }
                return graphics; // 返回图形
            }
        };
        
        // 加载资源
        this.load = {
            // 加载图像
            image: (key, url) => {
                const image = new Image(); // 创建图像元素
                image.src = url; // 设置源
                image.onload = () => {
                    this.textures[key] = image; // 保存纹理
                };
                return this; // 返回场景
            }
        };
        
        // 创建图形
        this.make = {
            // 创建图形
            graphics: (options) => {
                return this.add.graphics(options); // 创建图形
            }
        };
        
        // 添加时间事件
        this.time = {
            // 添加事件
            addEvent: (config) => {
                if (config.loop) {
                    const interval = setInterval(() => {
                        if (config.callback && config.callbackScope) {
                            config.callback.call(config.callbackScope); // 调用回调
                        } else if (config.callback) {
                            config.callback(); // 调用回调
                        }
                    }, config.delay || 1000); // 设置间隔
                    return { interval }; // 返回事件
                }
                return null; // 返回null
            }
        };
    }
    
    // 渲染所有对象
    renderObjects() {
        // 渲染子对象
        for (const child of this.children) {
            if (child.render) {
                child.render(this.game.context); // 渲染子对象
            }
        }
        
        // 渲染组
        for (const group of this.groups) {
            group.render(this.game.context); // 渲染组
        }
    }
};

// 输入系统
Phaser.Input = class {
    constructor(game) {
        this.game = game; // 游戏实例
        this.keys = {}; // 按键状态
        
        // 键盘事件
        window.addEventListener('keydown', (e) => {
            this.keys[e.keyCode] = true; // 设置按键状态
        });
        
        window.addEventListener('keyup', (e) => {
            this.keys[e.keyCode] = false; // 设置按键状态
        });
        
        // 键盘
        this.keyboard = {
            // 创建方向键
            createCursorKeys: () => {
                return {
                    up: { isDown: false },
                    down: { isDown: false },
                    left: { isDown: false },
                    right: { isDown: false }
                };
            },
            
            // 添加按键
            addKey: (keyCode) => {
                return { isDown: false }; // 返回按键
            }
        };
    }
    
    // 更新输入
    update() {
        // 更新方向键
        if (this.keyboard.cursors) {
            this.keyboard.cursors.up.isDown = this.keys[Phaser.Input.Keyboard.KeyCodes.UP]; // 更新上方向键
            this.keyboard.cursors.down.isDown = this.keys[Phaser.Input.Keyboard.KeyCodes.DOWN]; // 更新下方向键
            this.keyboard.cursors.left.isDown = this.keys[Phaser.Input.Keyboard.KeyCodes.LEFT]; // 更新左方向键
            this.keyboard.cursors.right.isDown = this.keys[Phaser.Input.Keyboard.KeyCodes.RIGHT]; // 更新右方向键
        }
    }
};

// 物理系统
Phaser.Physics = class {
    constructor(game) {
        this.game = game; // 游戏实例
        
        // 添加精灵
        this.add = {
            // 添加精灵
            sprite: (x, y, key) => {
                const sprite = new Phaser.Physics.Sprite(this.game.scene, x, y, key); // 创建物理精灵
                this.game.scene.children.push(sprite); // 添加到子对象
                return sprite; // 返回精灵
            },
            
            // 添加组
            group: () => {
                return new Phaser.Physics.Group(this.game.scene); // 创建物理组
            },
            
            // 添加碰撞
            overlap: (obj1, obj2, callback, processCallback, callbackContext) => {
                // 简化的碰撞检测
                return true; // 返回true
            }
        };
    }
    
    // 暂停物理系统
    pause() {
        // 暂停物理系统
    }
}; 